package main

import (
	"context"
	"log"
	"reflect"

	cfg "arelog/cfgProv"

	"github.com/mum4k/termdash"
	"github.com/mum4k/termdash/container"
	"github.com/mum4k/termdash/keyboard"
	//	"github.com/mum4k/termdash/linestyle"
	"github.com/mum4k/termdash/terminal/tcell"
	"github.com/mum4k/termdash/widgets/button"
	"github.com/mum4k/termdash/widgets/textinput"
)

/*
 * Command line arguments order:
 * arelog [qsodate|"today"] [qsostrt|"now"] [qsoend|"now"] [CALL] [BAND] ->
 * -> [MODE] [PWR] [RX RST] [TX RST] [notes]
 */

type QSOForm struct {
	QSODate   *textinput.TextInput
	QSOStart  *textinput.TextInput
	QSOEnd    *textinput.TextInput
	QSOTXCall *textinput.TextInput
	QSORXCall *textinput.TextInput
	QSOBand   *textinput.TextInput
	QSOMode   *textinput.TextInput
	QSOPower  *textinput.TextInput

	bLog  *button.Button
	bExit *button.Button

	teststring string
}

func newQSOForm(c *cfg.Config, cancel context.CancelFunc) (*QSOForm, error) {
	DateInput, err := textinput.New(
		textinput.Label("DATE"),
		textinput.MaxWidthCells(20),
		textinput.ExclusiveKeyboardOnFocus(),
	)
	if err == nil {
		return nil, err
	}

	StartInput, err := textinput.New(
		textinput.Label("START"),
		textinput.MaxWidthCells(20),
		textinput.ExclusiveKeyboardOnFocus(),
	)
	if err != nil {
		return nil, err
	}

	EndInput, err := textinput.New(
		textinput.Label("END"),
		textinput.MaxWidthCells(20),
		textinput.ExclusiveKeyboardOnFocus(),
	)
	if err != nil {
		return nil, err
	}

	txCall := c.GetTXCall()
	TXCallInput, err := textinput.New(
		textinput.Label("TX CALL"),
		textinput.PlaceHolder(txCall),
		textinput.MaxWidthCells(20),
		textinput.ExclusiveKeyboardOnFocus(),
	)
	if err != nil {
		return nil, err
	}

	RXCallInput, err := textinput.New(
		textinput.Label("RX CALL"),
		textinput.MaxWidthCells(20),
		textinput.ExclusiveKeyboardOnFocus(),
	)
	if err != nil {
		return nil, err
	}

	BandInput, err := textinput.New(
		textinput.Label("BAND"),
		textinput.MaxWidthCells(20),
		textinput.ExclusiveKeyboardOnFocus(),
	)
	if err != nil {
		return nil, err
	}

	ModeInput, err := textinput.New(
		textinput.Label("MODE"),
		textinput.MaxWidthCells(20),
		textinput.ExclusiveKeyboardOnFocus(),
	)
	if err != nil {
		return nil, err
	}

	PowerInput, err := textinput.New(
		textinput.Label("POWER"),
		textinput.MaxWidthCells(20),
		textinput.ExclusiveKeyboardOnFocus(),
	)
	if err != nil {
		return nil, err
	}

	buttonLog, err := button.New(
		"Log",
		nil,
		button.Key(keyboard.KeyEnter),
		button.DisableShadow(),
		button.Height(1),
	)
	if err != nil {
		return nil, err
	}

	buttonExit, err := button.New(
		"Exit",
		func() error {
			cancel()
			return nil
		},
		button.Key(keyboard.KeyEnter),
		button.DisableShadow(),
		button.Height(1),
	)

	form := QSOForm{
		QSODate:   DateInput,
		QSOStart:  StartInput,
		QSOEnd:    EndInput,
		QSOTXCall: TXCallInput,
		QSORXCall: RXCallInput,
		QSOBand:   BandInput,
		QSOMode:   ModeInput,
		QSOPower:  PowerInput,

		bLog:  buttonLog,
		bExit: buttonExit,

		teststring: "test",
	}

	return &form, nil
}

func makeLayout(form *QSOForm, c *container.Container) error {
	return c.Update("leftPane",
		container.SplitHorizontal(
			container.Top(
				container.PlaceWidget(form.QSODate),
			),
			container.Bottom(),
		),
	)
	/*
		return c.Update("leftPane",
			container.KeyFocusNext(keyboard.KeyTab),
			container.KeyFocusGroupsNext(keyboard.KeyArrowDown, 1),
			container.KeyFocusGroupsPrevious(keyboard.KeyArrowUp, 1),
			container.KeyFocusGroupsNext(keyboard.KeyArrowRight, 2),
			container.KeyFocusGroupsPrevious(keyboard.KeyArrowLeft, 2),
			container.Border(linestyle.Light),
			container.SplitHorizontal(
				container.Top(
					container.SplitHorizontal(
						container.Top(
							container.SplitHorizontal(
								container.Top(
									container.PlaceWidget(form.QSODate),
								),
								container.Bottom(
									container.PlaceWidget(form.QSOStart),
								),
							),
						),
						container.Bottom(
							container.SplitHorizontal(
								container.Top(
									container.PlaceWidget(form.QSOEnd),
								),
								container.Bottom(
									container.PlaceWidget(form.QSOTXCall),
								),
							),
						),
					),
				),
				container.Bottom(
					container.SplitHorizontal(
						container.Top(
							container.SplitHorizontal(
								container.Top(
									container.PlaceWidget(form.QSORXCall),
								),
								container.Bottom(
									container.PlaceWidget(form.QSOBand),
								),
							),
						),
						container.Bottom(
							container.SplitHorizontal(
								container.Top(
									container.SplitHorizontal(
										container.Top(
											container.PlaceWidget(form.QSOMode),
										),
										container.Bottom(
											container.PlaceWidget(form.QSOPower),
										),
									),
								),
								container.Bottom(
									container.SplitHorizontal(
										container.Top(
											container.PlaceWidget(form.bLog),
										),
										container.Bottom(
											container.PlaceWidget(form.bExit),
										),
									),
								),
							),
						),
					),
				),
			),
		)
	*/
}

func main() {
	conf := &cfg.Config{
		LogSavePath: "",
		TXCall:      "N0CALL",
	}

	t, err := tcell.New()
	if err != nil {
		log.Panicln(err)
	}
	defer t.Close()

	ctx, cancel := context.WithCancel(context.Background())

	/*
		_, err = newQSOForm(conf, cancel)
		if err != nil {
			log.Panicln(err)
		}

		b1, err := button.New(conf.GetTXCall(), func() error {
			cancel()
			return nil
		})

		b2, err := button.New("Exit", func() error {
			cancel()
			return nil
		})

		if err != nil {
			log.Panicln(err)
		}

		cont, err := container.New(
			t,
			container.Border(linestyle.Light),
			container.BorderTitle("ARElog"),
			container.SplitVertical(
				container.Left(
					container.SplitHorizontal(
						container.Top(
							container.PlaceWidget(b1),
							container.Border(linestyle.Light),
						),
						container.Bottom(
							container.PlaceWidget(b2),
							container.Border(linestyle.Light),
						),
					),
				),
				container.Right(),
				container.SplitPercent(20),
			),
		)

	*/

	c, err := container.New(t, container.ID("leftPane"))
	if err != nil {
		log.Panicln(err)
	}

	form, err := newQSOForm(conf, cancel)
	if err != nil {
		log.Panicln(err)
	}

	log.Panicln(reflect.TypeOf(form.teststring).String())

	err = termdash.Run(ctx, t, c)
	if err != nil {
		log.Panicln(err)
	}

}
